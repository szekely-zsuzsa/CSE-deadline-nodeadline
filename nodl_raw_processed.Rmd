---
title: "Srtoop no-deadline: creating processed data from raw"
author: "Zsuzsa Szekely"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: html_document
editor_options: 
  chunk_output_type: console
---

# Load packages

```{r load packages}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, osfr, janitor, lubridate, purrrlyr)
```

# Load helper functions

```{r load helper functions}
source("R/utils.R")
```

# Import data

```{r}
# Reading in data
raw <- read_csv("data/nodeadline/raw/raw_data.csv")
```

# Data sorting

## make only trial response data stay in the dataframe, remove all other rows (all the trials have a value in variable "word", all the other rows have no value there)

```{r}
response <- 
  raw %>% 
  filter(!is.na(word))
```

## create variable for identifying the different task sections (practice, response)

```{r}
response <- 
  response %>% 
  mutate(section = case_when(sender == "StroopPracticetrial" ~ "practice",
                             sender == "1_StroopTestTrial" ~ "test",
                             sender == "2_StroopTestTrial" ~ "test",
                             sender == "3_StroopTestTrial" ~ "test",
                             sender == "4_StroopTestTrial" ~ "test"
                             ))
```

# create variable for trial serial number within each section of each block

```{r}
response <- 
  response %>% 
  group_by(participant_id, blockId, section) %>%
  mutate(trialNumber = row_number()) %>% 
  ungroup()
```

# add variable storing whether the previous trial was congruent

```{r previous congruency}
response <-
  response %>%
  mutate(isPrevCongruent = case_when(trialNumber < 2 ~ NA_integer_,
                                     trialNumber >= 2 & lag(congruency) == "con" ~ 1L,
                                     trialNumber >= 2 & lag(congruency) == "inc" ~ 0L))
```

# Create condition variable based on the congruency of current and previous trials

* ii: incongruent follows incongruent
* ic: congruent follows incongruent
* ci: incongruent follows congruent
* cc: congruent follows congruent

```{r}
response <-
  response %>%
  mutate(condition = case_when(isPrevCongruent == 0L & congruency == "inc" ~ "ii",
                               isPrevCongruent == 0L & congruency == "con" ~ "ic",
                               isPrevCongruent == 1L & congruency == "inc" ~ "ci",
                               isPrevCongruent == 1L & congruency == "con" ~ "cc",
                               TRUE ~ NA_character_))
```

# we expect to be no missing value in variable "response" and "correct". let's check it.

```{r}
response %>%
  count(is.na(response))

response %>%
  count(is.na(correct))
```

# create new variable storing whether the previous trial was correct

```{r}
response <- 
  response %>% 
  mutate(isPrevCorrect = case_when(trialNumber < 2 ~ NA_integer_,
                                   trialNumber >= 2 & lag(correct) == TRUE ~ 1L,
                                   trialNumber >= 2 & lag(correct) == FALSE ~ 0L))
```








PARTICIPANT LEVEL EXCLUSIONS

* 1. participants who didn't finish the task will be excluded

(This step was conducted in the source_raw file, now we just check it.)
Each participant who completed the task should have data from 24 practice trials and 324 response trials (total = 348).

# check if the task was completed by everyone

```{r}
response %>% 
  group_by(participant_id) %>% 
  count(section) %>%
  mutate(complete = case_when(section == "practice" & n == 24 ~ "complete",
                              section == "test" & n == 324 ~ "complete", 
                              TRUE ~ "incomplete"
                              )) %>%
  ungroup() %>% 
  count(complete) # the result should equal to the number of participants (65) * number of sections (2)
```

* 2. participants with their mean accuracy below 70% of the mean accuracy of the whole sample will be excluded

# calculate accuracy of respondents and create variable (dropParticipantAcc) for accuracy-based exclusion

```{r}
# from now on we are only interested in response trials, so here we drop practice trials
## save practice trials to a separate df
practice <- response %>% 
  filter(section == "practice")

## keep only response trials in response df
response <- response %>% 
  filter(section == "test")

# calculate accuracy
response %>%
  group_by(participant_id, correct) %>%
  summarise(n = n()) %>%
  ungroup() %>% 
  group_by(participant_id) %>%
  mutate(N = sum(n),
         prop = n / N * 100,
         dropParticipantAcc = case_when(prop < 70 ~ 1L,
                                        TRUE ~ 0L))

response <- 
  response %>% 
  group_by(participant_id) %>%
  mutate(prop = sum(correct) / n() * 100,
         dropParticipantAcc = case_when(prop < 70 ~ 1L,
                                        TRUE ~ 0L)) %>% 
  ungroup()
```

# Number of participants dropped because of accuracy.

```{r}
response %>% 
  distinct(participant_id, dropParticipantAcc) %>% 
  group_by(dropParticipantAcc) %>%
  summarise(n = n()) %>% 
  ungroup()
```

# Get the id of the participants who will be dropped.

```{r}
response %>%
  filter(dropParticipantAcc == 1) %>%
  distinct(participant_id) # id of participants to be dropped: 60, 69
```

# Exclusion

```{r}
response <-
  response %>%
  group_by(participant_id) %>% 
  filter(!any(dropParticipantAcc == 1L))
```

Check if the exclusion was successful. There should be 63 respondents.
  
```{r}
response %>% 
  distinct(participant_id) %>% 
  nrow()
```

* 3. participants with mean RT more than 2.5 SDs away from the mean RT of the whole sample will be excluded

Calucalte the mean response time and SD for exclusion.
We calculate the mean RT for each participant and the grand mean RT for participant level exclusion.

```{r calculate mean response time}
participant_rt <- response %>%
  group_by(participant_id) %>% 
  mutate(personal_mean_rt = mean(duration, na.rm = TRUE),
         personal_sd_rt = sd(duration, na.rm = TRUE)) %>%
  ungroup() %>% 
  mutate(grand_mean_rt = mean(duration, na.rm = TRUE),
         grand_sd_rt = sd(duration, na.rm = TRUE))

# create variable indicating outliers
participant_rt <- participant_rt %>% 
  group_by(participant_id) %>% 
  mutate(drop_participant_rt = case_when(grand_mean_rt + 2.5 * grand_sd_rt < personal_mean_rt ~ 1L,
                                         grand_mean_rt - 2.5 * grand_sd_rt > personal_mean_rt ~ 1L,
                                         TRUE ~ 0L)) %>%
  ungroup()
```

Get the number of rt outliers

```{r}
participant_rt %>% 
  filter(drop_participant_rt == 1) %>%
  nrow()
```

Since there is nobody to be excluded, the next 4 steps are not required.

Get the number of participants per task before exclusion.

```{r}
# participant_rt %>%
#   distinct(participant_id) %>%
#   nrow()
```

Get the id of the participants who will be dropped.

```{r}
# participant_rt %>%
#   filter(drop_participant_rt == 1) %>%
#   distinct(participant_id)
```

Exclusion.

```{r participant level RT exclusion}
# response <- response %>% 
#   group_by(participant_id) %>% 
#   filter(!participant_id == "")
```

Check if the exclusion was successful. There should be ... participants remaining.
  
```{r}
# response %>% 
#   distinct(participant_id) %>% 
#   nrow()
```








TRIAL LEVEL EXCLUSIONS

* 1. exclude practice and calibration trials
* 2. exclude first response trial in each block for each participant
* 3. exclude rt outlier trials
* 4. exclude trials directly following outlier trials

For the rt analysis there are some more exclusion criteria:
* 5. exclude error trials
* 6. exclude trials directly following error trials


* 1. exclude practice and calibration trials

We have already saved practice trials into a separate df, so now we only have response trials in the "response" df.

* 2. exclude first response trial in each block for each participant

The task had 4 blocks. Therefore, the number of trials that will be dropped equals the number of participants multiplied by four. Lets check this.

```{r}
# get the number of participants
response %>% 
  distinct(participant_id) %>% 
  nrow()

# get the number of trials
nrow(response)

# get the number of first trials
response %>%
  filter(trialNumber == 1) %>%
  nrow()
```

Dropping first trials.

```{r}
response <- 
  response %>% 
  filter(trialNumber != 1) # 1st trial level exclusion criteria

# Other way to do this: !is.na(isPrevCongruent)

# check the number of first trials (it should be 0)
response %>%
  filter(trialNumber == 1) %>%
  nrow()

# check the number of remaining trials
nrow(response)
```

* 3. prepare exclusion of trials with RT more than 2.5 SDs away from conditional mean RT

Calculate the mean RT per condition (iI, iC, cI, cC)

```{r}
response <-
  response %>%
  group_by(participant_id, condition) %>% 
  mutate(rtConditionalMean = mean(duration, na.rm = T),
         rtConditionalSd = sd(duration, na.rm = T)) %>% 
  ungroup()
```

Create variable that stores whether a participant or a trial should be dropped based on the rt criteria

```{r}
response <- response %>% 
  group_by(participant_id) %>%
  mutate(dropTrialRt = case_when(rtConditionalMean + 2.5 * rtConditionalSd < duration ~ 1L,
                                 rtConditionalMean - 2.5 * rtConditionalSd > duration ~ 1L,
                                 TRUE ~ 0L),
# At this point there should be no trial == 1 trials because they were removed, trial == 2 trials will have NO previous trial as the immediately preceding trial will be the last trial of the previous block
         isPrevDropTrialRt = case_when(trialNumber == 2 ~ NA_integer_, 
                                       trialNumber > 2 & lag(dropTrialRt) == 1L ~ 1L,
                                       trialNumber > 2 & lag(dropTrialRt) == 0L ~ 0L)) %>% 
  ungroup()
```

Lets take a look at the number of the congruent and incongruent trials per condition.

```{r}
response %>% 
  group_by(condition) %>% 
  count()
```

* Drop outliers (trials 2.5 SDs away from the conditional mean of the participant)

```{r}
response <-
  response %>% 
  filter(dropTrialRt == 0L)
```

* 4. Drop trials following outlier trials

```{r trial level exclusion reaction time}
response <-
  response %>% 
  filter(isPrevDropTrialRt == 0L)
```

Check the number of the congruent and incongruent trials per condition again

```{r}
response %>% 
  group_by(condition) %>% 
  count()
```



# acc analysis exclusions

For the accuracy analysis there's no more exclusion criteria. We save the data into a separate df for accuracy analysis and we check if after the exclusions there is still some variance in the accuracy scores.

```{r}
responseAccAnalysis <- response

responseAccAnalysis %>% 
  group_by(condition) %>% 
  summarise(mean_acc = mean(correct, na.rm = TRUE),
            sd_acc = sd(correct, na.rm = TRUE))

responseAccAnalysis %>% 
  group_by(congruency) %>% 
  summarise(mean_acc = mean(correct, na.rm = TRUE),
            sd_acc = sd(correct, na.rm = TRUE))
```

## Checking whether there are trials remaining in each condition (ii, ic, ci, cc) from each participant for the accuracy analysis

```{r}
responseAccAnalysis %>% 
  count(participant_id, condition) %>% # get the number of trials per each participant in each condition
  filter(n != 0) %>% # drop those conditions with 0 trials
  group_by(participant_id) %>%
  summarise(n = n()) %>%  # get the number of remaining conditions per each participant
  filter(n != 4) %>% # see if there's anybody with less than 4 conditions
  nrow() # get the number of these participants
```

# Looking for ceiling effect regarding accuracy
## Mean and SD of accuracy of congruent and incongruent trials

```{r}
# creating variable (congruency_prop) for accuracy measured in congruent and incongruent trials
responseAccAnalysis <-
  responseAccAnalysis %>% 
  group_by(participant_id, congruency) %>% 
  mutate(congruency_prop = sum(correct) / n()*100,
         congruency_sd = sd(correct))

# calculating mean and SD of accuracy of congruent and incongruent trials 
responseAccAnalysis %>% 
  group_by(congruency) %>% 
  summarise(mean_acc = mean(congruency_prop),
            sd_acc = sd(congruency_prop),
            n_trial = n())
```

## Plots of accuracy distribution

```{r}
responseAccAnalysis %>% 
  group_by(participant_id) %>% 
  ggplot(aes(x = prop)) +
  geom_bar() +
  scale_y_continuous(limits = c(0, 1600)) +
  scale_x_continuous(limits = c(80, 101))
```



# rt analysis exclusions

For the rt analysis there are some more trial level exclusion criteria.

Create df for rt analysis, then exclude:
* 5. Error trials

```{r}
responseRtAnalysis <-
  response %>% 
  filter(correct == TRUE)
```

* 6. Trials following error trials

```{r}
responseRtAnalysis <-
  responseRtAnalysis %>% 
  filter(isPrevCorrect == 1L)
```

## Checking whether there are trials remaining in each condition (ii, ic, ci, cc) from each participant for the rt analysis

```{r}
responseRtAnalysis %>% 
  count(participant_id, condition) %>% # get the number of trials per each participant in each condition
  filter(n != 0) %>% # drop those conditions with 0 trials
  group_by(participant_id) %>%
  summarise(n = n()) %>%  # get the number of remaining conditions per participants
  filter(n != 4) %>% # see if there's anybody with less than 4 conditions
  nrow() # get the number of these participants
```








Save rt and acc analysis to separate dataframes

```{r save tasks}
# Saving data for the reaction time analysis
write_tsv(responseRtAnalysis, "data/nodeadline/processed/processed_data_rt.tsv")

# Saving data for the accuracy analysis
write_tsv(responseAccAnalysis, "data/nodeadline/processed/processed_data_acc.tsv")
```
